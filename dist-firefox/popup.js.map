{
  "version": 3,
  "sources": ["../node_modules/turndown/lib/turndown.browser.es.js", "../src/core/env.ts", "../src/core/logging.ts", "../src/core/converter.ts", "../src/platforms/chrome/adapters/chrome-dom-parser.ts", "../src/platforms/firefox/firefox-converter.ts", "../src/platforms/firefox/popup.ts"],
  "sourcesContent": ["function extend (destination) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) destination[key] = source[key];\n    }\n  }\n  return destination\n}\n\nfunction repeat (character, count) {\n  return Array(count + 1).join(character)\n}\n\nfunction trimLeadingNewlines (string) {\n  return string.replace(/^\\n*/, '')\n}\n\nfunction trimTrailingNewlines (string) {\n  // avoid match-at-end regexp bottleneck, see #370\n  var indexEnd = string.length;\n  while (indexEnd > 0 && string[indexEnd - 1] === '\\n') indexEnd--;\n  return string.substring(0, indexEnd)\n}\n\nvar blockElements = [\n  'ADDRESS', 'ARTICLE', 'ASIDE', 'AUDIO', 'BLOCKQUOTE', 'BODY', 'CANVAS',\n  'CENTER', 'DD', 'DIR', 'DIV', 'DL', 'DT', 'FIELDSET', 'FIGCAPTION', 'FIGURE',\n  'FOOTER', 'FORM', 'FRAMESET', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'HEADER',\n  'HGROUP', 'HR', 'HTML', 'ISINDEX', 'LI', 'MAIN', 'MENU', 'NAV', 'NOFRAMES',\n  'NOSCRIPT', 'OL', 'OUTPUT', 'P', 'PRE', 'SECTION', 'TABLE', 'TBODY', 'TD',\n  'TFOOT', 'TH', 'THEAD', 'TR', 'UL'\n];\n\nfunction isBlock (node) {\n  return is(node, blockElements)\n}\n\nvar voidElements = [\n  'AREA', 'BASE', 'BR', 'COL', 'COMMAND', 'EMBED', 'HR', 'IMG', 'INPUT',\n  'KEYGEN', 'LINK', 'META', 'PARAM', 'SOURCE', 'TRACK', 'WBR'\n];\n\nfunction isVoid (node) {\n  return is(node, voidElements)\n}\n\nfunction hasVoid (node) {\n  return has(node, voidElements)\n}\n\nvar meaningfulWhenBlankElements = [\n  'A', 'TABLE', 'THEAD', 'TBODY', 'TFOOT', 'TH', 'TD', 'IFRAME', 'SCRIPT',\n  'AUDIO', 'VIDEO'\n];\n\nfunction isMeaningfulWhenBlank (node) {\n  return is(node, meaningfulWhenBlankElements)\n}\n\nfunction hasMeaningfulWhenBlank (node) {\n  return has(node, meaningfulWhenBlankElements)\n}\n\nfunction is (node, tagNames) {\n  return tagNames.indexOf(node.nodeName) >= 0\n}\n\nfunction has (node, tagNames) {\n  return (\n    node.getElementsByTagName &&\n    tagNames.some(function (tagName) {\n      return node.getElementsByTagName(tagName).length\n    })\n  )\n}\n\nvar rules = {};\n\nrules.paragraph = {\n  filter: 'p',\n\n  replacement: function (content) {\n    return '\\n\\n' + content + '\\n\\n'\n  }\n};\n\nrules.lineBreak = {\n  filter: 'br',\n\n  replacement: function (content, node, options) {\n    return options.br + '\\n'\n  }\n};\n\nrules.heading = {\n  filter: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n  replacement: function (content, node, options) {\n    var hLevel = Number(node.nodeName.charAt(1));\n\n    if (options.headingStyle === 'setext' && hLevel < 3) {\n      var underline = repeat((hLevel === 1 ? '=' : '-'), content.length);\n      return (\n        '\\n\\n' + content + '\\n' + underline + '\\n\\n'\n      )\n    } else {\n      return '\\n\\n' + repeat('#', hLevel) + ' ' + content + '\\n\\n'\n    }\n  }\n};\n\nrules.blockquote = {\n  filter: 'blockquote',\n\n  replacement: function (content) {\n    content = content.replace(/^\\n+|\\n+$/g, '');\n    content = content.replace(/^/gm, '> ');\n    return '\\n\\n' + content + '\\n\\n'\n  }\n};\n\nrules.list = {\n  filter: ['ul', 'ol'],\n\n  replacement: function (content, node) {\n    var parent = node.parentNode;\n    if (parent.nodeName === 'LI' && parent.lastElementChild === node) {\n      return '\\n' + content\n    } else {\n      return '\\n\\n' + content + '\\n\\n'\n    }\n  }\n};\n\nrules.listItem = {\n  filter: 'li',\n\n  replacement: function (content, node, options) {\n    var prefix = options.bulletListMarker + '   ';\n    var parent = node.parentNode;\n    if (parent.nodeName === 'OL') {\n      var start = parent.getAttribute('start');\n      var index = Array.prototype.indexOf.call(parent.children, node);\n      prefix = (start ? Number(start) + index : index + 1) + '.  ';\n    }\n    content = content\n      .replace(/^\\n+/, '') // remove leading newlines\n      .replace(/\\n+$/, '\\n') // replace trailing newlines with just a single one\n      .replace(/\\n/gm, '\\n' + ' '.repeat(prefix.length)); // indent\n    return (\n      prefix + content + (node.nextSibling && !/\\n$/.test(content) ? '\\n' : '')\n    )\n  }\n};\n\nrules.indentedCodeBlock = {\n  filter: function (node, options) {\n    return (\n      options.codeBlockStyle === 'indented' &&\n      node.nodeName === 'PRE' &&\n      node.firstChild &&\n      node.firstChild.nodeName === 'CODE'\n    )\n  },\n\n  replacement: function (content, node, options) {\n    return (\n      '\\n\\n    ' +\n      node.firstChild.textContent.replace(/\\n/g, '\\n    ') +\n      '\\n\\n'\n    )\n  }\n};\n\nrules.fencedCodeBlock = {\n  filter: function (node, options) {\n    return (\n      options.codeBlockStyle === 'fenced' &&\n      node.nodeName === 'PRE' &&\n      node.firstChild &&\n      node.firstChild.nodeName === 'CODE'\n    )\n  },\n\n  replacement: function (content, node, options) {\n    var className = node.firstChild.getAttribute('class') || '';\n    var language = (className.match(/language-(\\S+)/) || [null, ''])[1];\n    var code = node.firstChild.textContent;\n\n    var fenceChar = options.fence.charAt(0);\n    var fenceSize = 3;\n    var fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');\n\n    var match;\n    while ((match = fenceInCodeRegex.exec(code))) {\n      if (match[0].length >= fenceSize) {\n        fenceSize = match[0].length + 1;\n      }\n    }\n\n    var fence = repeat(fenceChar, fenceSize);\n\n    return (\n      '\\n\\n' + fence + language + '\\n' +\n      code.replace(/\\n$/, '') +\n      '\\n' + fence + '\\n\\n'\n    )\n  }\n};\n\nrules.horizontalRule = {\n  filter: 'hr',\n\n  replacement: function (content, node, options) {\n    return '\\n\\n' + options.hr + '\\n\\n'\n  }\n};\n\nrules.inlineLink = {\n  filter: function (node, options) {\n    return (\n      options.linkStyle === 'inlined' &&\n      node.nodeName === 'A' &&\n      node.getAttribute('href')\n    )\n  },\n\n  replacement: function (content, node) {\n    var href = node.getAttribute('href');\n    if (href) href = href.replace(/([()])/g, '\\\\$1');\n    var title = cleanAttribute(node.getAttribute('title'));\n    if (title) title = ' \"' + title.replace(/\"/g, '\\\\\"') + '\"';\n    return '[' + content + '](' + href + title + ')'\n  }\n};\n\nrules.referenceLink = {\n  filter: function (node, options) {\n    return (\n      options.linkStyle === 'referenced' &&\n      node.nodeName === 'A' &&\n      node.getAttribute('href')\n    )\n  },\n\n  replacement: function (content, node, options) {\n    var href = node.getAttribute('href');\n    var title = cleanAttribute(node.getAttribute('title'));\n    if (title) title = ' \"' + title + '\"';\n    var replacement;\n    var reference;\n\n    switch (options.linkReferenceStyle) {\n      case 'collapsed':\n        replacement = '[' + content + '][]';\n        reference = '[' + content + ']: ' + href + title;\n        break\n      case 'shortcut':\n        replacement = '[' + content + ']';\n        reference = '[' + content + ']: ' + href + title;\n        break\n      default:\n        var id = this.references.length + 1;\n        replacement = '[' + content + '][' + id + ']';\n        reference = '[' + id + ']: ' + href + title;\n    }\n\n    this.references.push(reference);\n    return replacement\n  },\n\n  references: [],\n\n  append: function (options) {\n    var references = '';\n    if (this.references.length) {\n      references = '\\n\\n' + this.references.join('\\n') + '\\n\\n';\n      this.references = []; // Reset references\n    }\n    return references\n  }\n};\n\nrules.emphasis = {\n  filter: ['em', 'i'],\n\n  replacement: function (content, node, options) {\n    if (!content.trim()) return ''\n    return options.emDelimiter + content + options.emDelimiter\n  }\n};\n\nrules.strong = {\n  filter: ['strong', 'b'],\n\n  replacement: function (content, node, options) {\n    if (!content.trim()) return ''\n    return options.strongDelimiter + content + options.strongDelimiter\n  }\n};\n\nrules.code = {\n  filter: function (node) {\n    var hasSiblings = node.previousSibling || node.nextSibling;\n    var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;\n\n    return node.nodeName === 'CODE' && !isCodeBlock\n  },\n\n  replacement: function (content) {\n    if (!content) return ''\n    content = content.replace(/\\r?\\n|\\r/g, ' ');\n\n    var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? ' ' : '';\n    var delimiter = '`';\n    var matches = content.match(/`+/gm) || [];\n    while (matches.indexOf(delimiter) !== -1) delimiter = delimiter + '`';\n\n    return delimiter + extraSpace + content + extraSpace + delimiter\n  }\n};\n\nrules.image = {\n  filter: 'img',\n\n  replacement: function (content, node) {\n    var alt = cleanAttribute(node.getAttribute('alt'));\n    var src = node.getAttribute('src') || '';\n    var title = cleanAttribute(node.getAttribute('title'));\n    var titlePart = title ? ' \"' + title + '\"' : '';\n    return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : ''\n  }\n};\n\nfunction cleanAttribute (attribute) {\n  return attribute ? attribute.replace(/(\\n+\\s*)+/g, '\\n') : ''\n}\n\n/**\n * Manages a collection of rules used to convert HTML to Markdown\n */\n\nfunction Rules (options) {\n  this.options = options;\n  this._keep = [];\n  this._remove = [];\n\n  this.blankRule = {\n    replacement: options.blankReplacement\n  };\n\n  this.keepReplacement = options.keepReplacement;\n\n  this.defaultRule = {\n    replacement: options.defaultReplacement\n  };\n\n  this.array = [];\n  for (var key in options.rules) this.array.push(options.rules[key]);\n}\n\nRules.prototype = {\n  add: function (key, rule) {\n    this.array.unshift(rule);\n  },\n\n  keep: function (filter) {\n    this._keep.unshift({\n      filter: filter,\n      replacement: this.keepReplacement\n    });\n  },\n\n  remove: function (filter) {\n    this._remove.unshift({\n      filter: filter,\n      replacement: function () {\n        return ''\n      }\n    });\n  },\n\n  forNode: function (node) {\n    if (node.isBlank) return this.blankRule\n    var rule;\n\n    if ((rule = findRule(this.array, node, this.options))) return rule\n    if ((rule = findRule(this._keep, node, this.options))) return rule\n    if ((rule = findRule(this._remove, node, this.options))) return rule\n\n    return this.defaultRule\n  },\n\n  forEach: function (fn) {\n    for (var i = 0; i < this.array.length; i++) fn(this.array[i], i);\n  }\n};\n\nfunction findRule (rules, node, options) {\n  for (var i = 0; i < rules.length; i++) {\n    var rule = rules[i];\n    if (filterValue(rule, node, options)) return rule\n  }\n  return void 0\n}\n\nfunction filterValue (rule, node, options) {\n  var filter = rule.filter;\n  if (typeof filter === 'string') {\n    if (filter === node.nodeName.toLowerCase()) return true\n  } else if (Array.isArray(filter)) {\n    if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true\n  } else if (typeof filter === 'function') {\n    if (filter.call(rule, node, options)) return true\n  } else {\n    throw new TypeError('`filter` needs to be a string, array, or function')\n  }\n}\n\n/**\n * The collapseWhitespace function is adapted from collapse-whitespace\n * by Luc Thevenard.\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * collapseWhitespace(options) removes extraneous whitespace from an the given element.\n *\n * @param {Object} options\n */\nfunction collapseWhitespace (options) {\n  var element = options.element;\n  var isBlock = options.isBlock;\n  var isVoid = options.isVoid;\n  var isPre = options.isPre || function (node) {\n    return node.nodeName === 'PRE'\n  };\n\n  if (!element.firstChild || isPre(element)) return\n\n  var prevText = null;\n  var keepLeadingWs = false;\n\n  var prev = null;\n  var node = next(prev, element, isPre);\n\n  while (node !== element) {\n    if (node.nodeType === 3 || node.nodeType === 4) { // Node.TEXT_NODE or Node.CDATA_SECTION_NODE\n      var text = node.data.replace(/[ \\r\\n\\t]+/g, ' ');\n\n      if ((!prevText || / $/.test(prevText.data)) &&\n          !keepLeadingWs && text[0] === ' ') {\n        text = text.substr(1);\n      }\n\n      // `text` might be empty at this point.\n      if (!text) {\n        node = remove(node);\n        continue\n      }\n\n      node.data = text;\n\n      prevText = node;\n    } else if (node.nodeType === 1) { // Node.ELEMENT_NODE\n      if (isBlock(node) || node.nodeName === 'BR') {\n        if (prevText) {\n          prevText.data = prevText.data.replace(/ $/, '');\n        }\n\n        prevText = null;\n        keepLeadingWs = false;\n      } else if (isVoid(node) || isPre(node)) {\n        // Avoid trimming space around non-block, non-BR void elements and inline PRE.\n        prevText = null;\n        keepLeadingWs = true;\n      } else if (prevText) {\n        // Drop protection if set previously.\n        keepLeadingWs = false;\n      }\n    } else {\n      node = remove(node);\n      continue\n    }\n\n    var nextNode = next(prev, node, isPre);\n    prev = node;\n    node = nextNode;\n  }\n\n  if (prevText) {\n    prevText.data = prevText.data.replace(/ $/, '');\n    if (!prevText.data) {\n      remove(prevText);\n    }\n  }\n}\n\n/**\n * remove(node) removes the given node from the DOM and returns the\n * next node in the sequence.\n *\n * @param {Node} node\n * @return {Node} node\n */\nfunction remove (node) {\n  var next = node.nextSibling || node.parentNode;\n\n  node.parentNode.removeChild(node);\n\n  return next\n}\n\n/**\n * next(prev, current, isPre) returns the next node in the sequence, given the\n * current and previous nodes.\n *\n * @param {Node} prev\n * @param {Node} current\n * @param {Function} isPre\n * @return {Node}\n */\nfunction next (prev, current, isPre) {\n  if ((prev && prev.parentNode === current) || isPre(current)) {\n    return current.nextSibling || current.parentNode\n  }\n\n  return current.firstChild || current.nextSibling || current.parentNode\n}\n\n/*\n * Set up window for Node.js\n */\n\nvar root = (typeof window !== 'undefined' ? window : {});\n\n/*\n * Parsing HTML strings\n */\n\nfunction canParseHTMLNatively () {\n  var Parser = root.DOMParser;\n  var canParse = false;\n\n  // Adapted from https://gist.github.com/1129031\n  // Firefox/Opera/IE throw errors on unsupported types\n  try {\n    // WebKit returns null on unsupported types\n    if (new Parser().parseFromString('', 'text/html')) {\n      canParse = true;\n    }\n  } catch (e) {}\n\n  return canParse\n}\n\nfunction createHTMLParser () {\n  var Parser = function () {};\n\n  {\n    if (shouldUseActiveX()) {\n      Parser.prototype.parseFromString = function (string) {\n        var doc = new window.ActiveXObject('htmlfile');\n        doc.designMode = 'on'; // disable on-page scripts\n        doc.open();\n        doc.write(string);\n        doc.close();\n        return doc\n      };\n    } else {\n      Parser.prototype.parseFromString = function (string) {\n        var doc = document.implementation.createHTMLDocument('');\n        doc.open();\n        doc.write(string);\n        doc.close();\n        return doc\n      };\n    }\n  }\n  return Parser\n}\n\nfunction shouldUseActiveX () {\n  var useActiveX = false;\n  try {\n    document.implementation.createHTMLDocument('').open();\n  } catch (e) {\n    if (root.ActiveXObject) useActiveX = true;\n  }\n  return useActiveX\n}\n\nvar HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();\n\nfunction RootNode (input, options) {\n  var root;\n  if (typeof input === 'string') {\n    var doc = htmlParser().parseFromString(\n      // DOM parsers arrange elements in the <head> and <body>.\n      // Wrapping in a custom element ensures elements are reliably arranged in\n      // a single element.\n      '<x-turndown id=\"turndown-root\">' + input + '</x-turndown>',\n      'text/html'\n    );\n    root = doc.getElementById('turndown-root');\n  } else {\n    root = input.cloneNode(true);\n  }\n  collapseWhitespace({\n    element: root,\n    isBlock: isBlock,\n    isVoid: isVoid,\n    isPre: options.preformattedCode ? isPreOrCode : null\n  });\n\n  return root\n}\n\nvar _htmlParser;\nfunction htmlParser () {\n  _htmlParser = _htmlParser || new HTMLParser();\n  return _htmlParser\n}\n\nfunction isPreOrCode (node) {\n  return node.nodeName === 'PRE' || node.nodeName === 'CODE'\n}\n\nfunction Node (node, options) {\n  node.isBlock = isBlock(node);\n  node.isCode = node.nodeName === 'CODE' || node.parentNode.isCode;\n  node.isBlank = isBlank(node);\n  node.flankingWhitespace = flankingWhitespace(node, options);\n  return node\n}\n\nfunction isBlank (node) {\n  return (\n    !isVoid(node) &&\n    !isMeaningfulWhenBlank(node) &&\n    /^\\s*$/i.test(node.textContent) &&\n    !hasVoid(node) &&\n    !hasMeaningfulWhenBlank(node)\n  )\n}\n\nfunction flankingWhitespace (node, options) {\n  if (node.isBlock || (options.preformattedCode && node.isCode)) {\n    return { leading: '', trailing: '' }\n  }\n\n  var edges = edgeWhitespace(node.textContent);\n\n  // abandon leading ASCII WS if left-flanked by ASCII WS\n  if (edges.leadingAscii && isFlankedByWhitespace('left', node, options)) {\n    edges.leading = edges.leadingNonAscii;\n  }\n\n  // abandon trailing ASCII WS if right-flanked by ASCII WS\n  if (edges.trailingAscii && isFlankedByWhitespace('right', node, options)) {\n    edges.trailing = edges.trailingNonAscii;\n  }\n\n  return { leading: edges.leading, trailing: edges.trailing }\n}\n\nfunction edgeWhitespace (string) {\n  var m = string.match(/^(([ \\t\\r\\n]*)(\\s*))(?:(?=\\S)[\\s\\S]*\\S)?((\\s*?)([ \\t\\r\\n]*))$/);\n  return {\n    leading: m[1], // whole string for whitespace-only strings\n    leadingAscii: m[2],\n    leadingNonAscii: m[3],\n    trailing: m[4], // empty for whitespace-only strings\n    trailingNonAscii: m[5],\n    trailingAscii: m[6]\n  }\n}\n\nfunction isFlankedByWhitespace (side, node, options) {\n  var sibling;\n  var regExp;\n  var isFlanked;\n\n  if (side === 'left') {\n    sibling = node.previousSibling;\n    regExp = / $/;\n  } else {\n    sibling = node.nextSibling;\n    regExp = /^ /;\n  }\n\n  if (sibling) {\n    if (sibling.nodeType === 3) {\n      isFlanked = regExp.test(sibling.nodeValue);\n    } else if (options.preformattedCode && sibling.nodeName === 'CODE') {\n      isFlanked = false;\n    } else if (sibling.nodeType === 1 && !isBlock(sibling)) {\n      isFlanked = regExp.test(sibling.textContent);\n    }\n  }\n  return isFlanked\n}\n\nvar reduce = Array.prototype.reduce;\nvar escapes = [\n  [/\\\\/g, '\\\\\\\\'],\n  [/\\*/g, '\\\\*'],\n  [/^-/g, '\\\\-'],\n  [/^\\+ /g, '\\\\+ '],\n  [/^(=+)/g, '\\\\$1'],\n  [/^(#{1,6}) /g, '\\\\$1 '],\n  [/`/g, '\\\\`'],\n  [/^~~~/g, '\\\\~~~'],\n  [/\\[/g, '\\\\['],\n  [/\\]/g, '\\\\]'],\n  [/^>/g, '\\\\>'],\n  [/_/g, '\\\\_'],\n  [/^(\\d+)\\. /g, '$1\\\\. ']\n];\n\nfunction TurndownService (options) {\n  if (!(this instanceof TurndownService)) return new TurndownService(options)\n\n  var defaults = {\n    rules: rules,\n    headingStyle: 'setext',\n    hr: '* * *',\n    bulletListMarker: '*',\n    codeBlockStyle: 'indented',\n    fence: '```',\n    emDelimiter: '_',\n    strongDelimiter: '**',\n    linkStyle: 'inlined',\n    linkReferenceStyle: 'full',\n    br: '  ',\n    preformattedCode: false,\n    blankReplacement: function (content, node) {\n      return node.isBlock ? '\\n\\n' : ''\n    },\n    keepReplacement: function (content, node) {\n      return node.isBlock ? '\\n\\n' + node.outerHTML + '\\n\\n' : node.outerHTML\n    },\n    defaultReplacement: function (content, node) {\n      return node.isBlock ? '\\n\\n' + content + '\\n\\n' : content\n    }\n  };\n  this.options = extend({}, defaults, options);\n  this.rules = new Rules(this.options);\n}\n\nTurndownService.prototype = {\n  /**\n   * The entry point for converting a string or DOM node to Markdown\n   * @public\n   * @param {String|HTMLElement} input The string or DOM node to convert\n   * @returns A Markdown representation of the input\n   * @type String\n   */\n\n  turndown: function (input) {\n    if (!canConvert(input)) {\n      throw new TypeError(\n        input + ' is not a string, or an element/document/fragment node.'\n      )\n    }\n\n    if (input === '') return ''\n\n    var output = process.call(this, new RootNode(input, this.options));\n    return postProcess.call(this, output)\n  },\n\n  /**\n   * Add one or more plugins\n   * @public\n   * @param {Function|Array} plugin The plugin or array of plugins to add\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  use: function (plugin) {\n    if (Array.isArray(plugin)) {\n      for (var i = 0; i < plugin.length; i++) this.use(plugin[i]);\n    } else if (typeof plugin === 'function') {\n      plugin(this);\n    } else {\n      throw new TypeError('plugin must be a Function or an Array of Functions')\n    }\n    return this\n  },\n\n  /**\n   * Adds a rule\n   * @public\n   * @param {String} key The unique key of the rule\n   * @param {Object} rule The rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  addRule: function (key, rule) {\n    this.rules.add(key, rule);\n    return this\n  },\n\n  /**\n   * Keep a node (as HTML) that matches the filter\n   * @public\n   * @param {String|Array|Function} filter The unique key of the rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  keep: function (filter) {\n    this.rules.keep(filter);\n    return this\n  },\n\n  /**\n   * Remove a node that matches the filter\n   * @public\n   * @param {String|Array|Function} filter The unique key of the rule\n   * @returns The Turndown instance for chaining\n   * @type Object\n   */\n\n  remove: function (filter) {\n    this.rules.remove(filter);\n    return this\n  },\n\n  /**\n   * Escapes Markdown syntax\n   * @public\n   * @param {String} string The string to escape\n   * @returns A string with Markdown syntax escaped\n   * @type String\n   */\n\n  escape: function (string) {\n    return escapes.reduce(function (accumulator, escape) {\n      return accumulator.replace(escape[0], escape[1])\n    }, string)\n  }\n};\n\n/**\n * Reduces a DOM node down to its Markdown string equivalent\n * @private\n * @param {HTMLElement} parentNode The node to convert\n * @returns A Markdown representation of the node\n * @type String\n */\n\nfunction process (parentNode) {\n  var self = this;\n  return reduce.call(parentNode.childNodes, function (output, node) {\n    node = new Node(node, self.options);\n\n    var replacement = '';\n    if (node.nodeType === 3) {\n      replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);\n    } else if (node.nodeType === 1) {\n      replacement = replacementForNode.call(self, node);\n    }\n\n    return join(output, replacement)\n  }, '')\n}\n\n/**\n * Appends strings as each rule requires and trims the output\n * @private\n * @param {String} output The conversion output\n * @returns A trimmed version of the ouput\n * @type String\n */\n\nfunction postProcess (output) {\n  var self = this;\n  this.rules.forEach(function (rule) {\n    if (typeof rule.append === 'function') {\n      output = join(output, rule.append(self.options));\n    }\n  });\n\n  return output.replace(/^[\\t\\r\\n]+/, '').replace(/[\\t\\r\\n\\s]+$/, '')\n}\n\n/**\n * Converts an element node to its Markdown equivalent\n * @private\n * @param {HTMLElement} node The node to convert\n * @returns A Markdown representation of the node\n * @type String\n */\n\nfunction replacementForNode (node) {\n  var rule = this.rules.forNode(node);\n  var content = process.call(this, node);\n  var whitespace = node.flankingWhitespace;\n  if (whitespace.leading || whitespace.trailing) content = content.trim();\n  return (\n    whitespace.leading +\n    rule.replacement(content, node, this.options) +\n    whitespace.trailing\n  )\n}\n\n/**\n * Joins replacement to the current output with appropriate number of new lines\n * @private\n * @param {String} output The current conversion output\n * @param {String} replacement The string to append to the output\n * @returns Joined output\n * @type String\n */\n\nfunction join (output, replacement) {\n  var s1 = trimTrailingNewlines(output);\n  var s2 = trimLeadingNewlines(replacement);\n  var nls = Math.max(output.length - s1.length, replacement.length - s2.length);\n  var separator = '\\n\\n'.substring(0, nls);\n\n  return s1 + separator + s2\n}\n\n/**\n * Determines whether an input can be converted\n * @private\n * @param {String|HTMLElement} input Describe this parameter\n * @returns Describe what it returns\n * @type String|Object|Array|Boolean|Number\n */\n\nfunction canConvert (input) {\n  return (\n    input != null && (\n      typeof input === 'string' ||\n      (input.nodeType && (\n        input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11\n      ))\n    )\n  )\n}\n\nexport default TurndownService;\n", "/**\n * Centralized environment variable access for mdconv.\n * Provides type-safe access to debug flags and system settings.\n */\n\n/**\n * Get the process environment safely across different platforms.\n */\nfunction getProcessEnv(): Record<string, string | undefined> {\n  return (typeof globalThis !== 'undefined' && \n          (globalThis as any).process?.env) || {};\n}\n\n/**\n * Debug configuration consolidated from across the codebase.\n * Re-evaluates environment on each access for test compatibility.\n */\nexport const debugConfig = {\n  /** Enable all debug logging when set to \"1\" */\n  get allDebug(): boolean { return getProcessEnv().MDCONV_DEBUG === \"1\"; },\n  \n  /** Enable verbose HTML\u2192Markdown conversion debugging */\n  get inlineDebug(): boolean { return getProcessEnv().MDCONV_DEBUG_INLINE === \"1\"; },\n  \n  /** Enable clipboard debugging in Raycast adapter */\n  get clipboardDebug(): boolean { return [\"1\", \"true\", \"TRUE\"].includes(getProcessEnv().MDCONV_DEBUG_CLIPBOARD ?? \"\"); },\n  \n  /** Check if running in test environment */\n  get isTest(): boolean { return getProcessEnv().NODE_ENV === \"test\"; },\n} as const;\n\n/**\n * System locale information for clipboard operations.\n * Re-evaluates environment on each access for test compatibility.\n */\nconst localeConfig = {\n  /** Current LANG setting */\n  get lang(): string | undefined { return getProcessEnv().LANG; },\n  \n  /** Current LC_ALL setting */\n  get lcAll(): string | undefined { return getProcessEnv().LC_ALL; },\n  \n  /** Current LC_CTYPE setting */\n  get lcCtype(): string | undefined { return getProcessEnv().LC_CTYPE; },\n} as const;\n\n/**\n * Helper to create environment options for shell commands.\n * Ensures UTF-8 encoding locale for pbpaste operations.\n */\nexport function createUtf8Env(baseLocale?: string): Record<string, string> {\n  const env: Record<string, string> = {};\n  \n  // Copy existing environment, filtering out undefined values\n  Object.entries(getProcessEnv()).forEach(([key, value]) => {\n    if (value !== undefined) {\n      env[key] = value;\n    }\n  });\n  \n  // Get current LC_ALL value directly to avoid getter timing issues\n  const currentLcAll = getProcessEnv().LC_ALL;\n  \n  // Derive base locale from LC_ALL or default to en_US\n  // Handle complex Raycast locales like \"en_US-u-hc-h12-u-ca-gregory-u-nu-latn\"\n  const derivedLocale = baseLocale || \n    currentLcAll?.split('-')[0]?.split('.')[0] || \n    'en_US';\n  const utf8Locale = `${derivedLocale}.UTF-8`;\n  \n  // Debug logging for locale normalization\n  if (getProcessEnv().MDCONV_DEBUG_CLIPBOARD) {\n    console.log(`[env] Locale normalization: ${currentLcAll} \u2192 ${utf8Locale}`);\n  }\n  \n  // Force UTF-8 locale\n  env.LC_ALL = utf8Locale;\n  env.LANG = utf8Locale;\n  \n  return env;\n}", "/**\n * Simple, consistent logging for mdconv.\n * Provides LLM-readable patterns without over-engineering.\n */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\ntype LogComponent = 'converter' | 'clipboard' | 'dom-parser' | 'chrome-popup' | 'raycast-ui';\n\n// Simple standardized logging function\n// Creates consistent [mdconv:component] patterns for easy scanning\n\nimport { debugConfig } from \"./env.js\";\n\n/**\n * Simple standardized logging function for mdconv components.\n * Creates consistent [mdconv:component] patterns for easy scanning by LLMs and humans.\n * \n * @param level - Log severity level ('debug', 'info', 'warn', 'error')\n * @param component - Component identifier for categorization\n * @param message - Log message content\n * @param data - Optional additional data to include in the log\n */\nexport function mdlog(level: LogLevel, component: LogComponent, message: string, data?: any): void {\n  // Skip debug logs in production/test environments\n  if (level === 'debug') {\n    if (debugConfig.isTest) return;\n    if (!debugConfig.allDebug) return;\n  }\n\n  const prefix = `[mdconv:${component}]`;\n  const logMessage = data !== undefined ? `${prefix} ${message}` : `${prefix} ${message}`;\n\n  switch (level) {\n    case 'debug':\n      console.debug(logMessage, data);\n      break;\n    case 'info':\n      console.info(logMessage, data);\n      break;\n    case 'warn':\n      console.warn(logMessage, data);\n      break;\n    case 'error':\n      console.error(logMessage, data);\n      break;\n  }\n}", "import TurndownService from \"turndown\";\nimport { DOMParserAdapter } from \"./adapters/index.js\";\nimport { mdlog } from \"./logging.js\";\nimport { debugConfig } from \"./env.js\";\n\n/**\n * How to handle images during HTML to Markdown conversion.\n * - 'preserve': Convert all images to Markdown image syntax (default)\n * - 'preserve-external-only': Only preserve images with http/https URLs\n * - 'remove': Remove all images from the output\n */\nexport type ImageHandlingMode = 'preserve' | 'remove' | 'preserve-external-only';\n\nexport type ConversionOptions = {\n  domParserAdapter?: DOMParserAdapter;\n  /** Controls how images are handled during conversion. Defaults to 'preserve' */\n  imageHandling?: ImageHandlingMode;\n};\n\ntype ConversionContext = {\n  parser: DOMParserAdapter;\n};\n\nconst MONOSPACE_FONT_NAMES = new Set(\n  [\n    \"courier\",\n    \"courier new\",\n    \"consolas\",\n    \"lucida console\",\n    \"menlo\",\n    \"monaco\",\n    \"source code pro\",\n    \"fira code\",\n    \"inconsolata\",\n    \"ubuntu mono\",\n    \"roboto mono\",\n    \"jetbrains mono\",\n    \"pt mono\",\n    \"ibm plex mono\",\n    \"andale mono\",\n    \"monospace\",\n  ].map((name) => name.toLowerCase()),\n);\n\nconst BLOCK_TEXT_ELEMENTS = new Set([\n  \"P\",\n  \"DIV\",\n  \"SECTION\",\n  \"ARTICLE\",\n  \"UL\",\n  \"OL\",\n  \"LI\",\n  \"TABLE\",\n  \"THEAD\",\n  \"TBODY\",\n  \"TFOOT\",\n  \"TR\",\n  \"TH\",\n  \"TD\",\n  \"BLOCKQUOTE\",\n  \"PRE\",\n]);\n\n\n\nfunction clampHeading(level: number | null | undefined): number | null {\n  if (!level || Number.isNaN(level)) {\n    return null;\n  }\n  return Math.min(Math.max(level, 1), 6);\n}\n\nfunction extractHeadingLevelFromString(value: string | null | undefined): number | null {\n  if (!value) {\n    return null;\n  }\n  const headingMatch = value.match(/heading\\s*([1-6])/i) ?? value.match(/heading([1-6])/i);\n  if (headingMatch) {\n    return clampHeading(parseInt(headingMatch[1] ?? headingMatch[2], 10));\n  }\n  const outlineMatch = value.match(/outline\\s*level\\s*([1-6])/i);\n  if (outlineMatch) {\n    return clampHeading(parseInt(outlineMatch[1], 10));\n  }\n  return null;\n}\n\nfunction parseFontSize(value: string | null | undefined): number | null {\n  if (!value) {\n    return null;\n  }\n  const match = value.trim().match(/([0-9]+(?:\\.[0-9]+)?)(px|pt|rem|em)?/i);\n  if (!match) {\n    return null;\n  }\n  const size = parseFloat(match[1]);\n  const unit = (match[2] || \"px\").toLowerCase();\n  if (Number.isNaN(size)) {\n    return null;\n  }\n  switch (unit) {\n    case \"pt\":\n      return size * (96 / 72);\n    case \"rem\":\n      return size * 16;\n    case \"em\":\n      return size * 16;\n    default:\n      return size;\n  }\n}\n\nfunction inferHeadingLevelFromStyle(element: HTMLElement): number | null {\n  const style = element.style;\n  const fontSize = parseFontSize(style?.fontSize);\n  const fontWeight = style?.fontWeight?.toLowerCase();\n  const isBold = fontWeight === \"bold\" || (!!fontWeight && parseInt(fontWeight, 10) >= 600);\n  if (!fontSize || !isBold) {\n    return null;\n  }\n\n  if (fontSize >= 34) {\n    return 1;\n  }\n  if (fontSize >= 28) {\n    return 2;\n  }\n  if (fontSize >= 24) {\n    return 3;\n  }\n  if (fontSize >= 20) {\n    return 4;\n  }\n  if (fontSize >= 18) {\n    return 5;\n  }\n  if (fontSize >= 16) {\n    return 6;\n  }\n  return null;\n}\n\nfunction detectWordHeadingLevel(element: HTMLElement): number | null {\n  const role = element.getAttribute(\"role\");\n  if (role?.toLowerCase() === \"heading\") {\n    const ariaLevel = element.getAttribute(\"aria-level\") ?? element.dataset.ariaLevel;\n    const levelFromAria = clampHeading(parseInt(ariaLevel ?? \"\", 10));\n    if (levelFromAria) {\n      return levelFromAria;\n    }\n  }\n\n  const explicitDataAttr = element.getAttribute(\"data-ccp-parastyle\") ?? element.getAttribute(\"data-ccp-parastyle-name\");\n  const levelFromDataAttr = extractHeadingLevelFromString(explicitDataAttr);\n  if (levelFromDataAttr) {\n    return levelFromDataAttr;\n  }\n\n  const datasetValues = Object.values(element.dataset ?? {});\n  for (const value of datasetValues) {\n    const level = extractHeadingLevelFromString(value);\n    if (level) {\n      return level;\n    }\n  }\n\n  const classLevel = extractHeadingLevelFromString(element.className);\n  if (classLevel) {\n    return classLevel;\n  }\n\n  const styleAttr = element.getAttribute(\"style\");\n  const msoLevel = extractHeadingLevelFromString(styleAttr);\n  if (msoLevel) {\n    return msoLevel;\n  }\n\n  const inferred = inferHeadingLevelFromStyle(element);\n  if (inferred) {\n    const text = element.textContent?.trim() ?? \"\";\n    if (text.split(/\\s+/).length <= 12) {\n      return inferred;\n    }\n  }\n\n  return null;\n}\n\nfunction normalizeFontTokens(fontFamily: string | null | undefined): string[] {\n  if (!fontFamily) {\n    return [];\n  }\n  return fontFamily\n    .split(\",\")\n    .map((token) => token.replace(/[\"']/g, \"\").trim().toLowerCase())\n    .filter(Boolean);\n}\n\nfunction isMonospaceFontFamily(fontFamily: string | null | undefined): boolean {\n  const tokens = normalizeFontTokens(fontFamily);\n  return tokens.some((token) => MONOSPACE_FONT_NAMES.has(token));\n}\n\nfunction readInlineFontFamily(element: HTMLElement): string | null {\n  const inline = element.style?.fontFamily;\n  if (inline && inline.trim()) {\n    return inline;\n  }\n\n  const faceAttr = element.getAttribute(\"face\");\n  if (faceAttr && faceAttr.trim()) {\n    return faceAttr;\n  }\n\n  const styleAttr = element.getAttribute(\"style\");\n  if (styleAttr) {\n    const match = styleAttr.match(/font-family\\s*:\\s*([^;]+)/i);\n    if (match?.[1]) {\n      return match[1];\n    }\n  }\n\n  return null;\n}\n\nfunction promoteWordHeadingsInPlace(doc: Document) {\n  const paragraphs = Array.from(doc.body.querySelectorAll(\"p\"));\n  for (const paragraph of paragraphs) {\n    const level = detectWordHeadingLevel(paragraph);\n    if (!level) {\n      continue;\n    }\n    const headingTag = `h${level}` as keyof HTMLElementTagNameMap;\n    const heading = doc.createElement(headingTag);\n    heading.innerHTML = paragraph.innerHTML;\n    if (paragraph.id) {\n      heading.id = paragraph.id;\n    }\n    paragraph.replaceWith(heading);\n  }\n}\n\nfunction shouldTransformToCodeBlock(element: HTMLElement): boolean {\n  if (!element.textContent || !element.textContent.trim()) {\n    return false;\n  }\n\n  if (element.closest(\"pre, code\")) {\n    return false;\n  }\n\n  let encounteredMonospace = isMonospaceFontFamily(readInlineFontFamily(element));\n  const ownerDocument = element.ownerDocument;\n  const showElements = ownerDocument.defaultView?.NodeFilter?.SHOW_ELEMENT ?? 1;\n  const showText = ownerDocument.defaultView?.NodeFilter?.SHOW_TEXT ?? 4;\n  const walker = ownerDocument.createTreeWalker(element, showElements);\n\n  while (walker.nextNode()) {\n    const current = walker.currentNode as HTMLElement;\n\n    if (current === element) {\n      continue;\n    }\n\n    if (current.tagName === \"PRE\" || current.tagName === \"CODE\") {\n      return false;\n    }\n\n    const fontFamily = readInlineFontFamily(current);\n    if (!fontFamily) {\n      continue;\n    }\n\n    if (isMonospaceFontFamily(fontFamily)) {\n      encounteredMonospace = true;\n      continue;\n    }\n\n    return false;\n  }\n\n  const textWalker = ownerDocument.createTreeWalker(element, showText);\n\n  while (textWalker.nextNode()) {\n    const current = textWalker.currentNode as Text;\n    const value = current.textContent ?? \"\";\n    if (!value.trim()) {\n      continue;\n    }\n\n    let parent: HTMLElement | null = current.parentElement;\n    let monospaceAncestor = false;\n\n    while (parent) {\n      if (parent === element) {\n        if (isMonospaceFontFamily(readInlineFontFamily(parent))) {\n          monospaceAncestor = true;\n        }\n        break;\n      }\n\n      const fontFamily = readInlineFontFamily(parent);\n      if (fontFamily && isMonospaceFontFamily(fontFamily)) {\n        monospaceAncestor = true;\n        break;\n      }\n\n      parent = parent.parentElement;\n    }\n\n    if (!monospaceAncestor) {\n      return false;\n    }\n  }\n\n  return encounteredMonospace;\n}\n\nfunction transformMonospaceBlocks(doc: Document) {\n  const blocks = Array.from(doc.body.querySelectorAll<HTMLElement>(\"p, div\"));\n  for (const block of blocks) {\n    if (!shouldTransformToCodeBlock(block)) {\n      continue;\n    }\n\n    const pre = doc.createElement(\"pre\");\n    const code = doc.createElement(\"code\");\n    const text = extractMonospaceBlockText(block);\n    code.textContent = text;\n    pre.appendChild(code);\n\n    if (block.id) {\n      pre.id = block.id;\n    }\n\n    block.replaceWith(pre);\n  }\n}\n\nfunction extractMonospaceBlockText(element: HTMLElement): string {\n  const parts: string[] = [];\n  const ownerDocument = element.ownerDocument;\n  const nodeCtor = ownerDocument.defaultView?.Node;\n  const TEXT_NODE = nodeCtor?.TEXT_NODE ?? 3;\n  const ELEMENT_NODE = nodeCtor?.ELEMENT_NODE ?? 1;\n\n  function appendNewline() {\n    if (!parts.length) {\n      parts.push(\"\\n\");\n      return;\n    }\n    if (!parts[parts.length - 1].endsWith(\"\\n\")) {\n      parts.push(\"\\n\");\n    }\n  }\n\n  function serialize(node: Node) {\n    if (node.nodeType === TEXT_NODE) {\n      let text = (node.textContent ?? \"\").replace(/\\u00a0/g, \" \");\n      text = text.replace(/\\r\\n?/g, \"\\n\");\n      if (parts.length && parts[parts.length - 1].endsWith(\"\\n\")) {\n        text = text.replace(/^\\n+/, \"\");\n      }\n      text = text.replace(/\\n+/g, \" \");\n      if (text) {\n        parts.push(text);\n      }\n      return;\n    }\n\n    if (node.nodeType !== ELEMENT_NODE) {\n      return;\n    }\n\n    const el = node as HTMLElement;\n    const tag = el.tagName;\n\n    if (tag === \"BR\") {\n      parts.push(\"\\n\");\n      return;\n    }\n\n    for (const child of Array.from(el.childNodes)) {\n      serialize(child);\n    }\n\n    if (BLOCK_TEXT_ELEMENTS.has(tag)) {\n      appendNewline();\n    }\n  }\n\n  for (const child of Array.from(element.childNodes)) {\n    serialize(child);\n  }\n\n  let text = parts.join(\"\");\n  text = text.replace(/\\r\\n?/g, \"\\n\").replace(/\\u2028|\\u2029/g, \"\\n\");\n  text = text.replace(/[ \\t]+\\n/g, \"\\n\");\n  text = text.replace(/\\n{3,}/g, \"\\n\\n\");\n  text = text.replace(/^[\\n\\s]+/, \"\").replace(/[\\n\\s]+$/, \"\");\n  return text;\n}\n\nfunction convertMonospaceSpansToCode(doc: Document) {\n  const candidates = Array.from(doc.body.querySelectorAll(\"span, font, tt\")) as HTMLElement[];\n\n  for (const element of candidates) {\n    if (element.closest(\"pre, code\")) {\n      continue;\n    }\n\n    if (element.tagName !== \"TT\") {\n      const fontFamily = readInlineFontFamily(element);\n      if (!fontFamily || !isMonospaceFontFamily(fontFamily)) {\n        continue;\n      }\n    }\n\n    const textContent = element.textContent ?? \"\";\n    if (!textContent.trim()) {\n      continue;\n    }\n\n    let shouldSkip = false;\n    const descendants = Array.from(element.querySelectorAll(\"*\")) as HTMLElement[];\n    for (const descendant of descendants) {\n      const tag = descendant.tagName;\n      if (tag === \"A\" || tag === \"IMG\" || tag === \"CODE\" || tag === \"PRE\") {\n        shouldSkip = true;\n        break;\n      }\n      if (BLOCK_TEXT_ELEMENTS.has(tag)) {\n        shouldSkip = true;\n        break;\n      }\n    }\n\n    if (shouldSkip) {\n      continue;\n    }\n\n    let inlineText = textContent.replace(/\\u00a0/g, \" \");\n    inlineText = inlineText.replace(/\\r\\n?/g, \"\\n\");\n    inlineText = inlineText.replace(/\\s*\\n\\s*/g, \" \");\n    inlineText = inlineText.trim();\n\n    if (!inlineText) {\n      continue;\n    }\n\n    const code = doc.createElement(\"code\");\n    code.textContent = inlineText;\n    element.replaceWith(code);\n  }\n}\n\nfunction isBoldFontWeight(fontWeight: string | null | undefined): boolean {\n  if (!fontWeight) {\n    return false;\n  }\n  const normalized = fontWeight.trim().toLowerCase();\n  if (!normalized) {\n    return false;\n  }\n  if (normalized === \"bold\" || normalized === \"bolder\") {\n    return true;\n  }\n  const numeric = parseInt(normalized, 10);\n  return !Number.isNaN(numeric) && numeric >= 600;\n}\n\nfunction spanStyleIndicatesBold(span: HTMLSpanElement): boolean {\n  if (isBoldFontWeight(span.style?.fontWeight)) {\n    return true;\n  }\n  const styleAttr = span.getAttribute(\"style\") ?? \"\";\n  return /font-weight\\s*:\\s*(bold|[6-9]\\d\\d)/i.test(styleAttr);\n}\n\nfunction convertBoldSpansToStrong(doc: Document) {\n  const spans = Array.from(doc.body.querySelectorAll<HTMLSpanElement>(\"span\"));\n  for (const span of spans) {\n    if (span.closest(\"pre, code\")) {\n      continue;\n    }\n    const parentTag = span.parentElement?.tagName;\n    if (parentTag === \"STRONG\" || parentTag === \"B\") {\n      continue;\n    }\n    if (!spanStyleIndicatesBold(span)) {\n      continue;\n    }\n\n    const strong = doc.createElement(\"strong\");\n    strong.innerHTML = span.innerHTML;\n    for (const attribute of span.getAttributeNames()) {\n      if (attribute.toLowerCase() === \"style\") {\n        continue;\n      }\n      const value = span.getAttribute(attribute);\n      if (value !== null) {\n        strong.setAttribute(attribute, value);\n      }\n    }\n    span.replaceWith(strong);\n  }\n}\n\nfunction spanStyleIndicatesItalic(span: HTMLSpanElement): boolean {\n  const fontStyle = span.style?.fontStyle?.toLowerCase();\n  if (fontStyle === \"italic\" || fontStyle === \"oblique\") {\n    return true;\n  }\n  const styleAttr = span.getAttribute(\"style\") ?? \"\";\n  return /font-style\\s*:\\s*(italic|oblique)/i.test(styleAttr);\n}\n\nfunction convertItalicSpansToEm(doc: Document) {\n  const spans = Array.from(doc.body.querySelectorAll<HTMLSpanElement>(\"span\"));\n  for (const span of spans) {\n    if (span.closest(\"pre, code\")) {\n      continue;\n    }\n    const parentTag = span.parentElement?.tagName;\n    if (parentTag === \"EM\" || parentTag === \"I\") {\n      continue;\n    }\n    if (!spanStyleIndicatesItalic(span)) {\n      continue;\n    }\n\n    const em = doc.createElement(\"em\");\n    em.innerHTML = span.innerHTML;\n    for (const attribute of span.getAttributeNames()) {\n      if (attribute.toLowerCase() === \"style\") {\n        continue;\n      }\n      const value = span.getAttribute(attribute);\n      if (value !== null) {\n        em.setAttribute(attribute, value);\n      }\n    }\n    span.replaceWith(em);\n  }\n}\n\nfunction consolidateWordLists(doc: Document) {\n  const listContainers = Array.from(doc.body.querySelectorAll<HTMLElement>(\"div.ListContainerWrapper\"));\n\n  if (listContainers.length === 0) {\n    return;\n  }\n\n  const groups: HTMLElement[][] = [];\n  let currentGroup: HTMLElement[] = [];\n  let lastListId: string | null = null;\n  let lastListType: string | null = null;\n\n  for (const container of listContainers) {\n    const list = container.querySelector(\"ul, ol\") as HTMLElement;\n    if (!list) {\n      continue;\n    }\n\n    const listType = list.tagName.toLowerCase();\n    const listItem = list.querySelector(\"li\") as HTMLElement;\n    const listId = listItem?.getAttribute(\"data-listid\") || \"\";\n\n    const isSameGroup = listType === lastListType && listId === lastListId && lastListId !== null;\n\n    if (isSameGroup) {\n      currentGroup.push(container);\n    } else {\n      if (currentGroup.length > 0) {\n        groups.push(currentGroup);\n      }\n      currentGroup = [container];\n      lastListType = listType;\n      lastListId = listId;\n    }\n  }\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  }\n\n  for (const group of groups) {\n    if (group.length <= 1) {\n      continue;\n    }\n\n    const firstContainer = group[0];\n    const firstList = firstContainer.querySelector(\"ul, ol\") as HTMLElement;\n    if (!firstList) {\n      continue;\n    }\n\n    const allItems: HTMLElement[] = [];\n    for (const container of group) {\n      const list = container.querySelector(\"ul, ol\");\n      if (list) {\n        const items = Array.from(list.querySelectorAll(\"li\"));\n        allItems.push(...items);\n      }\n    }\n\n    firstList.innerHTML = \"\";\n    for (const item of allItems) {\n      firstList.appendChild(item);\n    }\n\n    for (let i = 1; i < group.length; i++) {\n      group[i].remove();\n    }\n  }\n}\n\nfunction isLegacyWordListParagraph(element: HTMLElement): boolean {\n  if (element.tagName !== \"P\") {\n    return false;\n  }\n  const styleAttr = element.getAttribute(\"style\") ?? \"\";\n  if (/mso-list/i.test(styleAttr)) {\n    return true;\n  }\n  if (/MsoListParagraph/i.test(element.className)) {\n    return true;\n  }\n  return false;\n}\n\nfunction extractWordListInfo(paragraph: HTMLElement, commentNodeType: number): { type: \"ul\" | \"ol\"; contentHtml: string } | null {\n  const markerSpan = paragraph.querySelector<HTMLElement>('span[style*=\"mso-list:Ignore\"]');\n  let listType: \"ul\" | \"ol\" | null = null;\n\n  if (markerSpan) {\n    const markerText = markerSpan.textContent ?? \"\";\n    listType = /^\\s*\\d+[\\.\\)]/.test(markerText.trim()) ? \"ol\" : \"ul\";\n  } else {\n    listType = detectListTypeFromContent(paragraph.textContent ?? \"\");\n  }\n\n  if (!listType) {\n    return null;\n  }\n\n  const clone = paragraph.cloneNode(true) as HTMLElement;\n  removeNodesByType(clone, commentNodeType);\n\n  if (markerSpan) {\n    const ignored = Array.from(clone.querySelectorAll<HTMLElement>('span[style*=\"mso-list:Ignore\"]'));\n    for (const span of ignored) {\n      span.remove();\n    }\n  } else {\n    removeLeadingListMarkerNodes(clone, listType);\n  }\n\n  const officeNodes = Array.from(clone.querySelectorAll<HTMLElement>(\"o\\\\:p\"));\n  for (const officeNode of officeNodes) {\n    officeNode.remove();\n  }\n\n  trimLeadingWhitespaceNodes(clone);\n\n  const contentHtml = clone.innerHTML.trim();\n  if (!contentHtml) {\n    return null;\n  }\n\n  return { type: listType, contentHtml };\n}\n\nfunction convertLegacyWordParagraphLists(doc: Document) {\n  const defaultView = doc.defaultView;\n  const commentNodeType = defaultView?.Node?.COMMENT_NODE ?? 8;\n  const children = Array.from(doc.body.children);\n  let currentList: { element: HTMLUListElement | HTMLOListElement; type: \"ul\" | \"ol\" } | null = null;\n\n  for (const child of children) {\n    const paragraph = child as HTMLElement;\n    if (!isLegacyWordListParagraph(paragraph)) {\n      currentList = null;\n      continue;\n    }\n\n  const info = extractWordListInfo(paragraph, commentNodeType);\n    if (!info) {\n      currentList = null;\n      continue;\n    }\n\n    const li = doc.createElement(\"li\");\n    li.innerHTML = info.contentHtml;\n\n    if (!currentList || currentList.type !== info.type) {\n      const listElement = doc.createElement(info.type);\n      currentList = { element: listElement, type: info.type };\n      paragraph.replaceWith(listElement);\n      listElement.appendChild(li);\n    } else {\n      currentList.element.appendChild(li);\n      paragraph.remove();\n    }\n  }\n}\n\nfunction replaceOfficeParagraphNodes(doc: Document) {\n  const officeNodes = Array.from(doc.body.querySelectorAll<HTMLElement>(\"o\\\\:p\"));\n  for (const node of officeNodes) {\n    const content = node.textContent && node.textContent.length > 0 ? node.textContent : \"\\u00a0\";\n    const textNode = doc.createTextNode(content);\n    node.replaceWith(textNode);\n  }\n}\n\nconst INLINE_TAGS_FOR_NBSP = new Set([\"A\", \"B\", \"I\", \"EM\", \"STRONG\", \"CODE\", \"SPAN\", \"SMALL\", \"BIG\", \"SUB\", \"SUP\"]);\n\nfunction detectListTypeFromContent(text: string): \"ul\" | \"ol\" | null {\n  const normalized = text.replace(/\\u00a0/g, \" \").trim();\n  if (!normalized) {\n    return null;\n  }\n  if (/^\\d+[\\.)]/.test(normalized)) {\n    return \"ol\";\n  }\n  if (/^[\u2022\u00B7o\\-*]/i.test(normalized)) {\n    return \"ul\";\n  }\n  return null;\n}\n\nfunction removeNodesByType(root: HTMLElement, nodeType: number) {\n  const stack: Node[] = [root];\n  while (stack.length > 0) {\n    const node = stack.pop()!;\n    for (const child of Array.from(node.childNodes)) {\n      if (child.nodeType === nodeType) {\n        child.parentNode?.removeChild(child);\n        continue;\n      }\n      stack.push(child);\n    }\n  }\n}\n\nfunction removeLeadingListMarkerNodes(element: HTMLElement, listType: \"ul\" | \"ol\") {\n  const document = element.ownerDocument;\n  const nodeCtor = document.defaultView?.Node;\n  const TEXT_NODE = nodeCtor?.TEXT_NODE ?? 3;\n  const ELEMENT_NODE = nodeCtor?.ELEMENT_NODE ?? 1;\n  const orderedPattern = /^\\s*\\d+[\\.)](?:\\s+|$)/;\n  const bulletPattern = /^\\s*[\u2022\u00B7o\\-*](?:\\s+|$)/i;\n  const pattern = listType === \"ol\" ? orderedPattern : bulletPattern;\n\n  while (element.firstChild) {\n    const child = element.firstChild;\n\n    if (child.nodeType === TEXT_NODE) {\n      const original = child.textContent ?? \"\";\n      const normalized = original.replace(/\\u00a0/g, \" \");\n\n      if (!normalized.trim()) {\n        child.parentNode?.removeChild(child);\n        continue;\n      }\n\n      if (pattern.test(normalized)) {\n        const stripped = normalized.replace(pattern, \"\");\n        const trimmed = stripped.replace(/^\\s+/, \"\");\n        if (trimmed) {\n          child.textContent = trimmed;\n        } else {\n          child.parentNode?.removeChild(child);\n        }\n        continue;\n      }\n\n      break;\n    }\n\n    if (child.nodeType === ELEMENT_NODE) {\n      const elementChild = child as HTMLElement;\n      if (elementChild.tagName === \"BR\") {\n        elementChild.remove();\n        continue;\n      }\n\n      if (elementChild.tagName === \"SPAN\" || elementChild.tagName === \"FONT\") {\n        removeLeadingListMarkerNodes(elementChild, listType);\n\n        const text = (elementChild.textContent ?? \"\").replace(/\\u00a0/g, \" \");\n        if (!text.trim()) {\n          elementChild.remove();\n          continue;\n        }\n        if (pattern.test(text)) {\n          elementChild.remove();\n          continue;\n        }\n        break;\n      }\n\n      break;\n    }\n\n    child.parentNode?.removeChild(child);\n  }\n}\n\nfunction trimLeadingWhitespaceNodes(element: HTMLElement) {\n  const document = element.ownerDocument;\n  const nodeCtor = document.defaultView?.Node;\n  const TEXT_NODE = nodeCtor?.TEXT_NODE ?? 3;\n  const ELEMENT_NODE = nodeCtor?.ELEMENT_NODE ?? 1;\n\n  while (element.firstChild) {\n    const child = element.firstChild;\n\n    if (child.nodeType === TEXT_NODE) {\n      const original = child.textContent ?? \"\";\n      const trimmed = original.replace(/^[\\s\\u00a0]+/, \"\");\n      if (trimmed.length === 0) {\n        child.parentNode?.removeChild(child);\n        continue;\n      }\n      if (trimmed.length !== original.length) {\n        child.textContent = trimmed;\n      }\n      break;\n    }\n\n    if (child.nodeType === ELEMENT_NODE && (child as HTMLElement).tagName === \"BR\") {\n      child.parentNode?.removeChild(child);\n      continue;\n    }\n\n    break;\n  }\n}\n\nfunction convertInlineBoundarySpacesToNbsp(doc: Document) {\n  const showText = doc.defaultView?.NodeFilter?.SHOW_TEXT ?? 4;\n  const walker = doc.createTreeWalker(doc.body, showText);\n  const nbsp = \"\\u00a0\";\n  const nodes: Text[] = [];\n\n  while (walker.nextNode()) {\n    nodes.push(walker.currentNode as Text);\n  }\n\n  for (const textNode of nodes) {\n    let value = textNode.nodeValue ?? \"\";\n    if (!value.includes(\" \") && !value.includes(\"\\n\")) {\n      continue;\n    }\n\n    const previousSibling = textNode.previousSibling;\n    const nextSibling = textNode.nextSibling;\n\n    if (value.startsWith(\" \") && previousSibling && previousSibling.nodeType === 1) {\n      const previousElement = previousSibling as HTMLElement;\n      if (INLINE_TAGS_FOR_NBSP.has(previousElement.tagName)) {\n        value = nbsp + value.slice(1);\n      }\n    }\n\n    if (value.endsWith(\" \") && nextSibling && nextSibling.nodeType === 1) {\n      const nextElement = nextSibling as HTMLElement;\n      if (INLINE_TAGS_FOR_NBSP.has(nextElement.tagName)) {\n        value = value.slice(0, -1) + nbsp;\n      }\n    }\n\n    textNode.nodeValue = value;\n  }\n}\n\nfunction resolveContext(options: ConversionOptions): ConversionContext {\n  if (options.domParserAdapter) {\n    return { parser: options.domParserAdapter };\n  }\n  if (typeof DOMParser === \"undefined\") {\n    throw new Error(\"DOMParser is not available. Provide domParserAdapter in ConversionOptions.\");\n  }\n  // Create a simple adapter wrapper for the global DOMParser\n  return { \n    parser: {\n      parseFromString: (html: string, type: string) => new DOMParser().parseFromString(html, type as DOMParserSupportedType)\n    }\n  };\n}\n\nfunction isGoogleDocsHtml(html: string): boolean {\n  return html.includes('docs-internal-guid-') || html.includes('id=\"docs-internal-guid-');\n}\n\nfunction normalizeGoogleDocsHtml(html: string, context: ConversionContext): string {\n  try {\n    const doc = context.parser.parseFromString(html, \"text/html\");\n    if (!doc?.body) {\n      return html;\n    }\n\n    // Remove the wrapper <b> tag that Google Docs adds\n    const wrapperB = doc.querySelector('b[id*=\"docs-internal-guid\"]') as HTMLElement;\n    if (wrapperB && wrapperB.style.fontWeight === 'normal') {\n      // Move all children out of the wrapper\n      const parent = wrapperB.parentNode;\n      if (parent) {\n        while (wrapperB.firstChild) {\n          parent.insertBefore(wrapperB.firstChild, wrapperB);\n        }\n        wrapperB.remove();\n      }\n    }\n\n    // Convert Google Docs inline styles to semantic HTML\n    convertGoogleDocsStylesToSemanticHtml(doc);\n    \n    // Detect and group consecutive monospace paragraphs into code blocks\n    groupMonospaceParagraphsIntoCodeBlocks(doc);\n\n    // Remove non-breaking spaces that Google Docs adds\n    removeNonBreakingSpaces(doc);\n\n  convertMonospaceSpansToCode(doc);\n    \n    // Apply some Word normalization techniques that also work for Google Docs\n    convertInlineBoundarySpacesToNbsp(doc);\n    convertBoldSpansToStrong(doc);\n    convertItalicSpansToEm(doc);\n\n    return doc.body.innerHTML;\n  } catch (error) {\n    return html;\n  }\n}\n\nfunction convertGoogleDocsStylesToSemanticHtml(doc: Document): void {\n  // Convert spans with font-weight:700 to <strong>, but not if they're inside headings\n  const boldSpans = doc.querySelectorAll('span[style*=\"font-weight:700\"]');\n  boldSpans.forEach(span => {\n    // Skip if this span is inside a heading element\n    const isInHeading = span.closest('h1, h2, h3, h4, h5, h6');\n    if (!isInHeading) {\n      const strong = doc.createElement('strong');\n      strong.innerHTML = span.innerHTML;\n      span.parentNode?.replaceChild(strong, span);\n    } else {\n      // For headings, just remove the span and keep the text content\n      const textNode = doc.createTextNode(span.textContent || '');\n      span.parentNode?.replaceChild(textNode, span);\n    }\n  });\n\n  // Convert spans with font-style:italic to <em>\n  const italicSpans = doc.querySelectorAll('span[style*=\"font-style:italic\"]');\n  italicSpans.forEach(span => {\n    const em = doc.createElement('em');\n    em.innerHTML = span.innerHTML;\n    span.parentNode?.replaceChild(em, span);\n  });\n}\n\nfunction removeNonBreakingSpaces(doc: Document): void {\n  if (!doc.body) {\n    return;\n  }\n\n  // First, normalize HTML entities\n  doc.body.innerHTML = doc.body.innerHTML.replace(/&nbsp;/g, \" \");\n\n  const showText = doc.defaultView?.NodeFilter?.SHOW_TEXT ?? 4;\n  const walker = doc.createTreeWalker(doc.body, showText);\n  const textNodes: Text[] = [];\n\n  while (walker.nextNode()) {\n    textNodes.push(walker.currentNode as Text);\n  }\n\n  for (const node of textNodes) {\n    const value = node.nodeValue;\n    if (!value || !value.includes(\"\\u00a0\")) {\n      continue;\n    }\n\n    const parentElement = node.parentElement ?? (node.parentNode as Element | null);\n    if (parentElement?.closest(\"pre, code\")) {\n      continue;\n    }\n\n    node.nodeValue = value.replace(/\\u00a0/g, \" \");\n  }\n}\n\nfunction groupMonospaceParagraphsIntoCodeBlocks(doc: Document): void {\n  // Find consecutive paragraphs with monospace font\n  const monospaceParas = Array.from(doc.querySelectorAll('p')).filter(p => {\n    const spans = p.querySelectorAll('span');\n    return Array.from(spans).some(span => {\n      const style = span.getAttribute('style') || '';\n      return style.includes('Courier New') || style.includes('monospace');\n    });\n  });\n\n  // Group consecutive monospace paragraphs\n  const groups: HTMLParagraphElement[][] = [];\n  let currentGroup: HTMLParagraphElement[] = [];\n\n  monospaceParas.forEach((para, index) => {\n    const prevPara = monospaceParas[index - 1];\n    const isConsecutive = prevPara && para.previousElementSibling === prevPara;\n\n    if (isConsecutive || currentGroup.length === 0) {\n      currentGroup.push(para);\n    } else {\n      if (currentGroup.length > 0) {\n        groups.push([...currentGroup]);\n      }\n      currentGroup = [para];\n    }\n  });\n\n  if (currentGroup.length > 0) {\n    groups.push(currentGroup);\n  }\n\n  // Convert groups to code blocks\n  groups.forEach(group => {\n    if (group.length >= 2) { // Only convert if multiple consecutive paragraphs\n      const pre = doc.createElement('pre');\n      const code = doc.createElement('code');\n      \n      const codeContent = group.map(para => {\n        // Extract text content, preserving line structure\n        return para.textContent?.trim() || '';\n      }).join('\\n');\n      \n      code.textContent = codeContent;\n      pre.appendChild(code);\n      \n      // Replace the first paragraph with the code block\n      group[0].parentNode?.replaceChild(pre, group[0]);\n      \n      // Remove the remaining paragraphs\n      group.slice(1).forEach(para => para.remove());\n    }\n  });\n}\n\nfunction normalizeWordHtml(html: string, context: ConversionContext): string {\n  try {\n    const doc = context.parser.parseFromString(html, \"text/html\");\n    if (!doc?.body) {\n      return html;\n    }\n\n    consolidateWordLists(doc);\n    convertLegacyWordParagraphLists(doc);\n    replaceOfficeParagraphNodes(doc);\n    convertInlineBoundarySpacesToNbsp(doc);\n    promoteWordHeadingsInPlace(doc);\n    transformMonospaceBlocks(doc);\n    convertMonospaceSpansToCode(doc);\n    convertBoldSpansToStrong(doc);\n    convertItalicSpansToEm(doc);\n\n    return doc.body.innerHTML;\n  } catch (error) {\n    return html;\n  }\n}\n\nfunction createTurndownService(imageHandling: ImageHandlingMode = 'preserve'): TurndownService {\n  const turndownInstance = new TurndownService({\n    headingStyle: \"atx\",\n    codeBlockStyle: \"fenced\",\n    linkStyle: \"inlined\",\n  });\n\n  turndownInstance.keep([\"pre\", \"code\"]);\n\n  // Custom rule to handle paragraphs inside list items (Word behavior)\n  turndownInstance.addRule(\"listParagraph\", {\n    filter: function (node) {\n      return !!(node.nodeName === \"P\" && node.parentNode && node.parentNode.nodeName === \"LI\");\n    },\n    replacement: function (content) {\n      return content;\n    },\n  });\n\n  // Custom list processing to fix spacing issues\n  turndownInstance.addRule(\"listItem\", {\n    filter: \"li\",\n    replacement: function (content, node, options) {\n      content = content\n        .replace(/^\\s+/, \"\")\n        .replace(/\\s+$/, \"\")\n        .replace(/\\n/gm, \"\\n    \");\n\n      const bullet = options.bulletListMarker || \"*\";\n      return bullet + \" \" + content + \"\\n\";\n    },\n  });\n\n  // Override list rules to process all items at once\n  turndownInstance.addRule(\"list\", {\n    filter: [\"ul\", \"ol\"],\n    replacement: function (content, node, options) {\n      const element = node as HTMLElement;\n      const listItems = Array.from(element.querySelectorAll(\"li\"));\n      const isOrdered = element.tagName.toLowerCase() === \"ol\";\n\n      const processedItems = listItems.map((li, index) => {\n        let itemContent = turndownInstance\n          .turndown(li.innerHTML)\n          .replace(/^\\s+/, \"\")\n          .replace(/\\s+$/, \"\")\n          .replace(/\\n/gm, \"\\n    \");\n\n        if (isOrdered) {\n          return `${index + 1}. ${itemContent}`;\n        } else {\n          const bullet = options.bulletListMarker || \"*\";\n          return `${bullet} ${itemContent}`;\n        }\n      });\n\n      return processedItems.join(\"\\n\") + \"\\n\";\n    },\n  });\n\n  // Custom rule to handle links and strip all title attributes for better compatibility\n  turndownInstance.addRule(\"links\", {\n    filter: \"a\",\n    replacement: function (content, node) {\n      const element = node as HTMLAnchorElement;\n      const href = element.getAttribute('href') || '';\n      \n      if (!href) {\n        return content;\n      }\n      \n      // Always return links without title attributes for maximum compatibility\n      return `[${content}](${href})`;\n    },\n  });\n\n  // Custom rule to handle images based on configuration\n  turndownInstance.addRule(\"images\", {\n    filter: \"img\",\n    replacement: function (content, node) {\n      const element = node as HTMLImageElement;\n\n      if (imageHandling === 'remove') {\n        return '';\n      }\n      \n      // Use getAttribute to get the original src value without JSDOM URL resolution\n      const src = element.getAttribute('src') || '';\n      const rawAlt = element.getAttribute('alt') || '';\n      const alt = rawAlt\n        .replace(/[\\r\\n]+/g, ' ')\n        .replace(/\\s{2,}/g, ' ')\n        .trim();\n      \n      if (!src) {\n        return '';\n      }\n      \n      // Handle different image types based on configuration\n      if (imageHandling === 'preserve-external-only') {\n        // Only preserve images with external URLs (http/https)\n        if (!src.match(/^https?:\\/\\//i)) {\n          return '';\n        }\n      }\n      \n      // Return standard Markdown image syntax\n      return `![${alt}](${src})`;\n    },\n  });\n\n  return turndownInstance;\n}\n\n/**\n * Converts HTML content to Markdown format with platform-specific optimizations.\n * Handles Word, Google Docs, and web content with configurable image processing.\n * \n * @param html - The HTML string to convert to Markdown\n * @param options - Configuration options for conversion behavior\n * @returns The converted Markdown string, or empty string if input is invalid\n */\nexport function convertHtmlToMarkdown(html: string, options: ConversionOptions = {}): string {\n  // Validate input\n  if (!html || typeof html !== 'string') {\n    return '';\n  }\n\n  const context = resolveContext(options);\n  \n  // Detect source and apply appropriate normalization\n  let normalized: string;\n  if (isGoogleDocsHtml(html)) {\n    normalized = normalizeGoogleDocsHtml(html, context);\n  } else {\n    normalized = normalizeWordHtml(html, context);\n  }\n\n  // Create TurndownService instance with image handling configuration\n  const turndownInstance = createTurndownService(options.imageHandling);\n  \n  const markdown = turndownInstance.turndown(normalized);\n \n  if (debugConfig.inlineDebug && normalized.includes(\"monospace\")) {\n    mdlog('debug', 'converter', 'Normalized HTML:', normalized);\n    mdlog('debug', 'converter', 'Resulting Markdown:', markdown);\n  }\n  return markdown.replace(/\\u00a0/g, \" \").replace(/[ \\t]+\\n/g, \"\\n\");\n}\n\n/**\n * Converts clipboard content to Markdown format with fallback handling.\n * Prioritizes HTML content over plain text when both are available.\n * \n * @param html - Optional HTML content from clipboard (preferred)\n * @param plain - Optional plain text content from clipboard (fallback)\n * @param options - Configuration options for conversion behavior\n * @returns The converted Markdown string, or empty string if no valid content\n */\nexport function convertClipboardPayload(html?: string, plain?: string, options: ConversionOptions = {}): string {\n  // Ensure html is a string before calling trim()\n  if (html && typeof html === 'string' && html.trim()) {\n    return convertHtmlToMarkdown(html, options);\n  }\n  // Ensure plain is a string before calling trim()\n  if (plain && typeof plain === 'string') {\n    return plain.trim();\n  }\n  return \"\";\n}\n", "import { DOMParserAdapter } from \"../../../core/adapters/index.js\";\n\n/**\n * Chrome extension DOM parser adapter using the browser's native DOMParser.\n */\nexport class ChromeDOMParserAdapter implements DOMParserAdapter {\n  parseFromString(html: string, type: string): Document {\n    return new DOMParser().parseFromString(html, type as DOMParserSupportedType);\n  }\n}", "/**\n * Firefox extension converter wrapper.\n * Provides Firefox-specific conversion functionality using shared core logic.\n */\nimport { convertClipboardPayload as coreConvertClipboardPayload, ConversionOptions } from \"../../core/converter.js\";\nimport { ChromeDOMParserAdapter } from \"../chrome/adapters/chrome-dom-parser.js\";\n\n// Create a single adapter instance for reuse\nconst firefoxDOMParser = new ChromeDOMParserAdapter();\n\n/**\n * Firefox converter interface for converting clipboard payloads to Markdown.\n * Uses standard web APIs that work identically in Firefox and Chrome.\n */\nexport const firefoxConverter = {\n  convertClipboardPayload: (html?: string, plain?: string, options: ConversionOptions = {}): string => {\n    return coreConvertClipboardPayload(html, plain, {\n      ...options,\n      domParserAdapter: firefoxDOMParser\n    });\n  }\n};\n", "/**\n * Firefox extension popup script.\n * Handles clipboard conversion UI interactions.\n * Uses browser.* API which works in both Firefox and modern Chrome.\n */\n\n// Cross-browser compatibility shim - Firefox provides browser, Chrome provides chrome\n// Note: popup.ts doesn't use browser API directly, but imports from firefox-converter\n// which needs the shim for consistency\n\nimport { firefoxConverter } from \"./firefox-converter.js\";\n\ntype Tone = \"info\" | \"success\" | \"error\";\n\ntype UIRefs = {\n  pasteButton: HTMLButtonElement;\n  clearButton: HTMLButtonElement;\n  output: HTMLTextAreaElement;\n  status: HTMLElement;\n};\n\nconst DEBUG_CLIPBOARD_FLAG = \"mdconv.debugClipboard\";\n\nfunction isClipboardDebugEnabled(): boolean {\n  try {\n    return localStorage.getItem(DEBUG_CLIPBOARD_FLAG) === \"true\";\n  } catch (error) {\n    return false;\n  }\n}\n\ntype ClipboardDebugPayload = {\n  source: string;\n  html?: string | null;\n  plain?: string | null;\n  markdown?: string | null;\n};\n\nfunction logClipboardDebug(payload: ClipboardDebugPayload) {\n  if (!isClipboardDebugEnabled()) {\n    return;\n  }\n\n  const { source, html, plain, markdown } = payload;\n  const group = `[mdconv] ${source}`;\n\n  if (typeof console.groupCollapsed === \"function\") {\n    console.groupCollapsed(group);\n  } else {\n    console.log(group);\n  }\n\n  if (html !== undefined) {\n    console.log(`HTML (${html ? `${html.length} chars` : \"none\"})`);\n    if (html) {\n      console.log(html);\n    }\n  }\n\n  if (plain !== undefined) {\n    console.log(`Plain (${plain ? `${plain.length} chars` : \"none\"})`);\n    if (plain) {\n      console.log(plain);\n    }\n  }\n\n  if (markdown !== undefined) {\n    console.log(`Markdown (${markdown ? `${markdown.length} chars` : \"none\"})`);\n    if (markdown) {\n      console.log(markdown);\n    }\n  }\n\n  if (typeof console.groupEnd === \"function\") {\n    console.groupEnd();\n  }\n}\n\nfunction formatPreview(value: string | undefined | null, limit = 10000): string {\n  if (!value) {\n    return \"(none)\";\n  }\n  const trimmed = value.replace(/\\s+/g, \" \").trim();\n  if (trimmed.length <= limit) {\n    return trimmed;\n  }\n  return `${trimmed.slice(0, limit)}\u2026 [truncated ${trimmed.length - limit} chars]`;\n}\n\n\n\nfunction queryUI(): UIRefs | null {\n  const pasteButton = document.getElementById(\"pasteButton\") as HTMLButtonElement | null;\n  const clearButton = document.getElementById(\"clearButton\") as HTMLButtonElement | null;\n  const output = document.getElementById(\"output\") as HTMLTextAreaElement | null;\n  const status = document.getElementById(\"status\");\n\n  if (!pasteButton || !clearButton || !output || !status) {\n    return null;\n  }\n\n  return { pasteButton, clearButton, output, status };\n}\n\nfunction setStatus(refs: UIRefs, message: string, tone: Tone = \"info\") {\n  refs.status.textContent = message;\n  refs.status.dataset.tone = message ? tone : \"\";\n}\n\nasync function writeClipboard(text: string) {\n  await navigator.clipboard.writeText(text);\n}\n\nasync function readClipboardAsHtml(): Promise<{ html?: string; plain?: string }> {\n  if (navigator.clipboard && \"read\" in navigator.clipboard) {\n    try {\n      const items = await navigator.clipboard.read();\n      for (const item of items) {\n        if (item.types.includes(\"text/html\")) {\n          const blob = await item.getType(\"text/html\");\n          const html = await blob.text();\n          const plain = await item.getType(\"text/plain\").then((b) => b.text()).catch(() => \"\");\n          return { html, plain };\n        }\n      }\n    } catch (error) {\n      // Fallback to readText\n    }\n  }\n\n  const plain = await navigator.clipboard.readText();\n  return { plain };\n}\nasync function presentMarkdown(refs: UIRefs, markdown: string, context: string) {\n  refs.output.value = markdown;\n  setStatus(refs, `${context}. Copying Markdown to clipboard\u2026`, \"info\");\n\n  try {\n    await writeClipboard(markdown);\n    setStatus(refs, `${context}. Markdown copied to clipboard.`, \"success\");\n  } catch (error) {\n    setStatus(refs, \"Failed to copy to clipboard\", \"error\");\n  }\n}\n\nasync function handleConversion(refs: UIRefs) {\n  setStatus(refs, \"Reading clipboard\u2026\", \"info\");\n  try {\n    const { html, plain } = await readClipboardAsHtml();\n    logClipboardDebug({ source: \"clipboard.read\", html, plain });\n    const markdown = firefoxConverter.convertClipboardPayload(html, plain);\n    logClipboardDebug({ source: \"clipboard.read -> markdown\", markdown });\n\n    if (!markdown) {\n      setStatus(refs, \"No convertible content found on the clipboard.\", \"error\");\n      refs.output.value = \"\";\n      return;\n    }\n\n    const context = html ? \"Converted rich text from clipboard\" : \"Converted plain text from clipboard\";\n    await presentMarkdown(refs, markdown, context);\n  } catch (error) {\n    setStatus(refs, \"Conversion failed. Please try again.\", \"error\");\n  }\n}\n\nasync function handlePasteEvent(refs: UIRefs, event: ClipboardEvent) {\n  event.preventDefault();\n  const html = event.clipboardData?.getData(\"text/html\");\n  const plain = event.clipboardData?.getData(\"text/plain\");\n  logClipboardDebug({ source: \"paste\", html, plain });\n  const markdown = firefoxConverter.convertClipboardPayload(html, plain);\n  logClipboardDebug({ source: \"paste -> markdown\", markdown });\n\n  if (!markdown) {\n    setStatus(refs, \"Clipboard data was empty.\", \"error\");\n    refs.output.value = \"\";\n    return;\n  }\n\n  const context = html ? \"Converted pasted rich text\" : \"Converted pasted text\";\n  await presentMarkdown(refs, markdown, context);\n}\n\nasync function init() {\n  const refs = queryUI();\n  if (!refs) {\n    return;\n  }\n\n  refs.output.value = \"\";\n  setStatus(refs, \"\", \"info\");\n\n  refs.pasteButton.addEventListener(\"click\", () => {\n    void handleConversion(refs);\n  });\n\n  document.addEventListener(\"paste\", (event) => {\n    void handlePasteEvent(refs, event);\n  });\n\n  refs.clearButton.addEventListener(\"click\", () => {\n    refs.output.value = \"\";\n    setStatus(refs, \"\", \"info\");\n  });\n}\n\nvoid init();\n"],
  "mappings": "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",
  "names": ["rules", "isBlock", "isVoid", "node", "next", "root", "text", "root", "document", "plain"]
}
