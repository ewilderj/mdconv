{
  "version": 3,
  "sources": ["../src/platforms/firefox/background.ts"],
  "sourcesContent": ["/**\n * Firefox extension background script.\n * Handles context menu creation and selection-to-markdown conversion.\n * Uses browser.* API which works in both Firefox and modern Chrome.\n */\n/// <reference types=\"chrome\" />\n\n// Cross-browser compatibility shim - Firefox provides browser, Chrome provides chrome\ndeclare const browser: typeof chrome;\nif (typeof browser === 'undefined') {\n  // @ts-ignore - make browser available in Chrome\n  globalThis.browser = chrome;\n}\n\nbrowser.runtime.onInstalled.addListener(() => {\n  // Create context menu item\n  browser.contextMenus.create({\n    id: \"copyAsMarkdown\",\n    title: \"Copy as Markdown\",\n    contexts: [\"selection\"]\n  });\n});\n\nbrowser.contextMenus.onClicked.addListener(async (info, tab) => {\n  if (info.menuItemId === \"copyAsMarkdown\" && info.selectionText && tab?.id) {\n    try {\n      let response;\n      \n      try {\n        // Try to send message to content script first\n        response = await browser.tabs.sendMessage(tab.id, {\n          action: \"convertSelection\"\n        });\n      } catch (error) {\n        // If content script isn't available, inject it and try again\n        await browser.scripting.executeScript({\n          target: { tabId: tab.id },\n          files: ['content-script.js']\n        });\n        \n        // Wait a moment for the script to load\n        await new Promise(resolve => setTimeout(resolve, 100));\n        \n        // Try sending the message again\n        response = await browser.tabs.sendMessage(tab.id, {\n          action: \"convertSelection\"\n        });\n      }\n      \n      if (response && response.success) {\n        // Show success badge\n        await browser.action.setBadgeText({ text: \"\u2713\" });\n        await browser.action.setBadgeBackgroundColor({ color: \"#1b8a5a\" });\n      } else {\n        throw new Error(response?.error || \"Conversion failed\");\n      }\n      \n      // Clear badge after 2 seconds\n      setTimeout(() => {\n        browser.action.setBadgeText({ text: \"\" });\n      }, 2000);\n      \n    } catch (error) {\n      // Show error badge\n      await browser.action.setBadgeText({ text: \"\u2717\" });\n      await browser.action.setBadgeBackgroundColor({ color: \"#d93025\" });\n      \n      setTimeout(() => {\n        browser.action.setBadgeText({ text: \"\" });\n      }, 2000);\n    }\n  }\n});\n"],
  "mappings": ";AASA,IAAI,OAAO,YAAY,aAAa;AAElC,aAAW,UAAU;AACvB;AAEA,QAAQ,QAAQ,YAAY,YAAY,MAAM;AAE5C,UAAQ,aAAa,OAAO;AAAA,IAC1B,IAAI;AAAA,IACJ,OAAO;AAAA,IACP,UAAU,CAAC,WAAW;AAAA,EACxB,CAAC;AACH,CAAC;AAED,QAAQ,aAAa,UAAU,YAAY,OAAO,MAAM,QAAQ;AAC9D,MAAI,KAAK,eAAe,oBAAoB,KAAK,iBAAiB,KAAK,IAAI;AACzE,QAAI;AACF,UAAI;AAEJ,UAAI;AAEF,mBAAW,MAAM,QAAQ,KAAK,YAAY,IAAI,IAAI;AAAA,UAChD,QAAQ;AAAA,QACV,CAAC;AAAA,MACH,SAAS,OAAO;AAEd,cAAM,QAAQ,UAAU,cAAc;AAAA,UACpC,QAAQ,EAAE,OAAO,IAAI,GAAG;AAAA,UACxB,OAAO,CAAC,mBAAmB;AAAA,QAC7B,CAAC;AAGD,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,GAAG,CAAC;AAGrD,mBAAW,MAAM,QAAQ,KAAK,YAAY,IAAI,IAAI;AAAA,UAChD,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAEA,UAAI,YAAY,SAAS,SAAS;AAEhC,cAAM,QAAQ,OAAO,aAAa,EAAE,MAAM,SAAI,CAAC;AAC/C,cAAM,QAAQ,OAAO,wBAAwB,EAAE,OAAO,UAAU,CAAC;AAAA,MACnE,OAAO;AACL,cAAM,IAAI,MAAM,UAAU,SAAS,mBAAmB;AAAA,MACxD;AAGA,iBAAW,MAAM;AACf,gBAAQ,OAAO,aAAa,EAAE,MAAM,GAAG,CAAC;AAAA,MAC1C,GAAG,GAAI;AAAA,IAET,SAAS,OAAO;AAEd,YAAM,QAAQ,OAAO,aAAa,EAAE,MAAM,SAAI,CAAC;AAC/C,YAAM,QAAQ,OAAO,wBAAwB,EAAE,OAAO,UAAU,CAAC;AAEjE,iBAAW,MAAM;AACf,gBAAQ,OAAO,aAAa,EAAE,MAAM,GAAG,CAAC;AAAA,MAC1C,GAAG,GAAI;AAAA,IACT;AAAA,EACF;AACF,CAAC;",
  "names": []
}
